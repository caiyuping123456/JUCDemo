/**
 * @author caiyuping
 * @date 2026/2/13 16:09
 * @description: 业务
 */
public class _02_volatileFence {
    /**
     * 内存屏障：
     *      是一种同步屏障指令，是CPU或者编译器对内存随机访问的操作中的一个同步点，使得这个点之前的所有读写操作都在执行后才能进行这个点之后的操作。
     *      避免了代码重排序，内存屏蔽就是一种JVM指令，Java内存模型的重排序会要求Java编译器在生成JVM指令的内存屏蔽指令，通过内存屏蔽指令，
     *      volatile实现了Java内存模型中的可见性和有序性（禁止重排序），但是volatile无法保证原子性。
     *
     *      内存屏蔽前的所有写操作写回主内存
     *      内存屏障之后所有的读操作，就必须把内存屏蔽前的写操作的最新结果。
     *
     *      告诉处理器之前的写操作都写回主内存（写后读）
     *
     *  重排序： 不存在数据依赖可以进行重排序，但是其他情况不可以
     *
     *  内存屏蔽分类：
     *        粗分：
     *          - 读屏障（Load）：在读指令之前插入读屏障，让工作内存或者CPU高速缓存中的缓存数据失败，重新回到主内存中获取数据
     *          - 写屏障（Store）：在写指令之后插入写屏障，将数据刷回主内存
     *
     *        细分：
     *          - LoadLoad：保证Load1的读操作在Load2及后续读取操作之前执行
     *          - StoreStore：在Store2及其后的写操作执行前，保证Store1写操作已经刷回主内存中
     *          - LoadStore：在Store2及其后的写操作执行前，保证Load1的读操作已经结束
     *          - StoreLoad：在Store1的写操作已经刷新到主内存之后，Load2及其后的读操作才能执行
     */

    /**
     * 什么叫保证有序性：通过禁重排=>使用内存屏障
     *      第一个操作是volatile读操作时，第二个操作不管是什么，都不能进行指令重排
     *      第二个操作是volatile写操作时，不管第一个操作是什么，都不能进行指令重排
     *      第一个操作时volatile写操作时，第二个操作是volatile读操作时，不可以进行指令重排
     *
     *      volatile读之后插入LoadLoad和LoadStore
     *      volatile写之前插入StoreStore和之后插入一个StoreLoad
     */
}
