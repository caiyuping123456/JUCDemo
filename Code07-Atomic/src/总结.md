## 一、AtomicReference
- 作用
  - 对对象引用做原子更新，线程安全。
- 底层：CAS + volatile，无锁。
- 核心方法
  - get() / set()
  - compareAndSet(expect, update) 最关键
  - getAndSet()
- 特点
  - 只保证引用替换原子，不保证对象内部属性原子。
  - 会有 ABA 问题，解决用 AtomicStampedReference。
- 一句话总结
  - AtomicReference 是无锁、线程安全的对象引用更新工具。
## 二、AtomicIntegerFieldUpdater
- 作用
  - 不把字段改成 AtomicInteger，直接对类里的 volatile int 字段做原子操作。
  - 必须满足 3 个条件
  - 字段必须是 volatile int
  - 不能是 static、final
  - 权限要够（public/protected 同包）
- 优点
  - 字段还是原生 int，省内存、兼容旧代码。
  - 无锁 CAS，性能比 synchronized 好。
- 一句话总结
  - AtomicIntegerFieldUpdater 是反射式字段原子更新器，让普通 volatile int 拥有原子能力。
## 三、LongAdder（高并发重点！面试高频）
- 为什么出现？
  - AtomicLong 在高并发下：
    - 所有线程抢一个变量 → CAS 大量失败 → CPU 空转，性能暴跌。
- LongAdder 核心思想（面试官最爱）
  - 分段锁思想 + 分散热点
  - 一个值拆成：base + Cell [] 数组
  - 线程通过哈希落到不同 Cell 上更新
  - 冲突被分散，吞吐量大幅提升
  - 底层结构（Striped64）
  - base：低并发直接用
  - Cell[] cells：高并发分段
  - cellsBusy：保护数组初始化 / 扩容
- 执行流程（简单说）
  - 先尝试更新 base
  - 冲突 → 用 Cell 分段
  - Cell 还冲突 → 扩容（2 倍） 
  - 求和：sum = base + 所有Cell.value
- 优缺点
  - ✅ 高并发性能远超 AtomicLong
  - ❌ sum () 不是原子快照，是近似值
  - ❌ 不支持 compareAndSet 全局值
- 一句话总结
  - LongAdder 用分段分散 CAS 冲突，高并发累加性能最强，但 sum 是最终一致性。
## 三者对比（面试直接说）
- AtomicReference：原子更新对象引用
- AtomicIntegerFieldUpdater：原子更新普通 volatile int 字段
- LongAdder：高并发累加专用，分段减少竞争，性能最强