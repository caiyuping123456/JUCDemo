## 一、CAS 核心定义
CAS（Compare-And-Swap，比较并交换）是一种无锁的原子操作，核心目标是解决多线程并发下的同步问题 —— 它通过硬件级别的原子指令，保证「比较内存值 + 更新新值」的操作不可中断，相比传统的synchronized锁更轻量，是 Java 并发编程的核心基础。
## 二、CAS 的核心逻辑（三要素 + 执行流程）
1. 核心三要素
- V：待操作的内存地址对应的「当前旧值」；
- A：线程预期的「旧值」（线程认为内存中应该有的值）；
- B：线程想要更新的「新值」。
2. 执行流程（原子性，不可拆分）
- 比较：线程先读取内存中的值 V，判断是否与自己的预期值 A 一致；
- 交换：若一致，将内存值 V 更新为新值 B，返回「更新成功」；若不一致，不做任何操作，返回「更新失败」；
- 重试（可选）：更新失败的线程可选择自旋重试，或放弃操作。
## 三、Java 中的 CAS 应用（面试高频例子）
Java 在java.util.concurrent.atomic包下提供了基于 CAS 实现的原子类，例如：
- AtomicInteger：其incrementAndGet()（原子自增）方法，底层通过 Unsafe 类调用 CPU 的cmpxchg原子指令实现 CAS，无需加锁即可保证自增操作的原子性；
- 其他原子类：AtomicLong、AtomicBoolean、AtomicReference（支持对象类型的 CAS）。
## 四、CAS 的优缺点（面试必答）
1. 优点
- 无锁开销：无需加锁 / 释放锁，避免了线程上下文切换的性能损耗，高并发下性能优于synchronized；
- 非阻塞：更新失败的线程不会被挂起，可自行决定重试或放弃，灵活性更高；
- 硬件级原子性：依赖 CPU 原生指令保证操作不可中断，比纯软件同步更可靠。
2. 缺点
- ABA 问题：线程 1 准备将值从 A 更新为 B，但期间线程 2 先把 A 改成 B、又改回 A，线程 1 的 CAS 会误判「值未修改」并成功更新，可能导致数据不一致；
  - → 解决：使用AtomicStampedReference（给值加版本号，比较「值 + 版本号」，版本号变化则拒绝更新）。
- 自旋开销：高并发下若 CAS 持续失败，线程会循环重试，占用 CPU 资源；
- 单变量限制：CAS 仅能保证单个变量操作的原子性，多变量原子操作仍需依赖锁或AtomicReference（将多变量包装为对象）。
## 五、CAS 的典型应用场景
- Java 并发工具：ConcurrentHashMap（JDK1.8 后用 CAS 替代部分分段锁）、ThreadPoolExecutor（核心参数ctl的原子更新）、CountDownLatch等；
- 原子类：Atomic系列原子类，解决基本类型 / 对象的并发更新问题；
- 分布式锁：Redis 的SETNX指令（本质是 CAS 思想，仅当键不存在时设置值）；
- 数据库乐观锁：基于版本号 / 时间戳的乐观锁，核心逻辑与 CAS 一致（比较版本号，匹配则更新）。
## 面试精简回答模板（1 分钟内讲清核心）
- “CAS 是比较并交换的缩写，是无锁的原子操作，核心是「比较内存旧值与线程预期值，匹配则更新为新值」，靠硬件指令保证原子性，三要素是旧值、预期值、新值。
- Java 中 AtomicInteger 等原子类基于 CAS 实现，优点是无锁、性能高，缺点主要是 ABA 问题（可加版本号解决）、自旋开销、仅支持单变量原子性。
- 常见应用在并发工具类、线程池、分布式锁等场景，是 Java 并发的核心基础。”